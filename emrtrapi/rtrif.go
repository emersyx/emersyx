package emrtr

import (
	"errors"
	"plugin"
)

// Router is the interface which must be implemented by all emersyx routers. The standard router implementation follows
// this interface, and the emersyx core also expects implementations to follow it.
type Router interface {
	// LoadGateways must accept as arguments a variable number of emcomapi.Identifiable objects. Some objects may also
	// implement the emcomapi.Receptor interface - these objects are covered by the Run method.
	LoadGateways(gws ...emcomapi.Identifiable) error
	// GetGateway must search for the emcomapi.Identifiable object loaded with LoadGateways and with the specified
	// identifier. If such an object is found, then it must be returned.
	GetGateway(id string) (emcomapi.Identifiable, error)
	// LoadProcessors must accept as arguments a variable number of emcomapi.Processor objects.
	LoadProcessors(procs ...emcomapi.Processor) error
	// NewRoute must create internally a new route for events generated by the emcomapi.Gateway with source identifier
	// to all emcomapi.Processor objects with destination identifiers. If the emcomapi.Gateway with source identifier
	// does not implement the emcomapi.Receptor interface, then an error message must be returned.
	NewRoute(source string, destination ...string) error
	// Run must start a loop in which events coming from 1a) the emcomapi.Identifiable objects 2a) loaded via the
	// LoadGateways method and 3a) which also implement the emcomapi.Receptor interface are router to 1b) the
	// emcomapi.Processor objects 2b) loaded via the LoadProcessors function. The events should follow the routes
	// generated via the NewRoute method.
	Run() error
}

// NewRouter calls the function with the same name exported by the specified plugin and returns the same value returned
// by the exported function.
func NewRouter(plug *plugin.Plugin, cfg string) (Router, error) {
	if plug == nil {
		return nil, errors.New("invalid plugin handle")
	}

	f, err := plug.Lookup("NewRouter")
	if err != nil {
		return nil, errors.New("the router plugin does not have the NewRouter symbol")
	}

	fc, ok := f.(func(cfg string) (Router, error))
	if ok == false {
		return nil, errors.New("the NewRouter function does not have the correct signature")
	}

	return fc(cfg)
}
